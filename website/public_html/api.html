<!DOCTYPE html>

<html lang="en">
    <head>
      <!-- Metadata -->
      <title>Scavenger Hunt</title>

      <!-- Theme stylesheets -->
      <link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css" rel="stylesheet" />
      <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" rel="stylesheet"/>
      <link href="css/style.css" rel="stylesheet"/>
      <link href="css/leader.css" rel="stylesheet"/>

      <!-- Fonts -->
      <link href='https://fonts.googleapis.com/css?family=Oswald:400,700' rel='stylesheet' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Avenir' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Ubuntu' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Roboto' type='text/css'>

      <!-- Global scripts -->
      <script src="https://unpkg.com/scrollreveal@4"></script>
      <script src="https://www.gstatic.com/firebasejs/5.9.3/firebase.js"></script>
      <script src="../script/firebase_init.js"></script>
      <script src="css/formBE/vendor/jquery/jquery.min.js"></script>
      <script src="css/formBE/js/main.js"></script>

      <!-- Page-specific scripts -->
      <link href="css/prism.css" rel="stylesheet"/>
    </head>
    <body>
        <div id="navbar"></div>
        <div class="content">
        <section id="main" class = "full">
            <section id="content">
                <!--<p> A task library includes a set of scavenger hunt tasks for robots. On the mornings of game days, a list of tasks will be randomly selected from the task library and posted on the page of results. Specific types of tasks from the library might appear more than once or not at all. It is not mandatory for the robot to follow the order of tasks on the list when working on the tasks. Instead, we encourage robots to dynamically adjust the order of tasks in such a way that they judge will maximize their overall score. For instance, tasks requiring long-distance navigation can be executed at times when humans have fewer activities, e.g., early mornings, while tasks require human-robot interactions can be attempted during hours when people are more accessible. However, this reordering should be done fully autonomously: once the robot downloads the task list, its only input from a person should be as specified by the tasks themselves. </p>

                <p> A task specification is a four-tuple: <br />⟨ <br /> task name, format, score, description <br /> ⟩ </p>

                <p> The name is a unique string that usually includes fewer than four words in English. The format specifies the format of completion certificate (e.g., jpg for images and txt for plain texts). The score defines the reward a robot can receive when the task is finished within the game day and the certificate meets the requirements specified in the task description. Finally, in the description, we describe the requirements that a completion certificate needs to meet so the robot can earn the full score, and in case of partial completion or partial correctness, how we award partial credit. </p>

                <p> At the beginning of each game day (when the robot downloads the task list), a profile needs to be submitted for each robot player. This profile includes a map of the game environment for that robot, the initial location of the robot within that map and some statistics about the robot's capabilities. By the end of each game day, a game report needs to be collected from each robot that participated in the scavenger hunt game on that day - no matter whether the robot has finished the given list of tasks or not. </p>

                <p> Such results can be used for statistical analysis over a long period of time. A game report is in the form: robot name, traveled distance, start time, finish time, task results, where the traveled distance records the distance covered between the start time and the finish time on that day (both are local time in format YYYYMMDD:HHMMSS). The task results is a set of results that each identifies the task name and the path to the completion certificate, where the path provides a link by which the completion certificate is publicly available. </p>

                <p> Task results: <br /> ⟨ <br /> task name 1, certificate 1, time stamp 1, path to certificate 1, <br /> task name 2, certificate 2, time stamp 2, path to certificate 2, <br /> ...<br /> ⟩ </p>-->

<h2>Scavenger Hunt API</h2>

<p>
Participating in hunts requires a robot use the Scavenger Hunt API to interface
with the website. The core API is robot-agnostic and can stand alone, though
a ROS wrapper is also provided.
</p>

<p>
This page details how to use the ROS wrapper. For robots that are not ROS-based,
see <a href="api-nonros.html">this guide</a>.
</p>

<p>
Click the button below to download the Scavenger Hunt API.
</p>

<form method="get" action="file.doc">
  <div style="text-align: center;">
    <button id="export-btn" class="btn btn-primary" type="submit" style="width: 33%;">Get Scavenger Hunt API</button>
  </div>
</form>

<hr>
<h2>Launch Parameters</h2>

<p>
Before launching anything, edit the launch parameters in
<code>scavenger_hunt/config/scavenger_hunt.yaml</code>. These are picked up by
<code>scavenger_hunt.launch</code>.
</p>

<p>
Enter your Scavenger Hunt login credentials in the
<code>scavenger_hunt/login/email</code> and <code>scavenger_hunt/login/password</code>
fields.
</p>

<p>
<code>scavenger_hunt/scratch_path</code> should contain a valid path that the
node will have permission to create files in. The upload process may create
temporary files in this location to aid with image transport.
</code>
</p>

<p>
Once the parameters are in place and the package is built, you can launch
Scavenger Hunt services with <code>roslaunch scavenger_hunt scavenger_hunt.launch</code>.
</p>

<hr>
<h2>Downloading Hunts</h2>

The main node offers a service with default name <code>/scavenger_hunt/get_hunt</code>
that is used to download task lists from the website. Hunts are queried by name.
We've created a never expiring hunt called Bottle Hunt for you to test with.
You can, of course, create your own hunts as well.

<pre>
  <code class="language-cpp">
#include &lt;scavenger_hunt_msgs/GetHunt.h&gt;
#include &lt;scavenger_hunt_msgs/Hunt.h&gt;
#include &lt;scavenger_hunt_msgs/Task.h&gt;

...

ros::NodeHandle nh;
ros::ServiceClient client_get_hunt = nh.serviceClient&lt;scavenger_hunt_msgs::GetHunt&gt;(
  "/scavenger_hunt/get_hunt"
);

scavenger_hunt_msgs::GetHunt get_hunt;
get_hunt.request.hunt_name = "Bottle Hunt"; // Name of the hunt to download
client_get_hunt.call(get_hunt);
scavenger_hunt_msgs::Hunt hunt = get_hunt.response.hunt;
  </code>
</pre>

A <code>scavenger_hunt_msgs::Hunt</code> contains a list of
<code>scavenger_hunt_msgs::Task</code>. Each member of the list represents a
different task in the hunt with details on how to complete it.

<pre>
  <code class="language-cpp">
for (scavenger_hunt_msgs::Task& task : hunt.tasks) {
  std::string task_name = task.name;
  std::string parameter = task.parameters[0].value;
  // See Task.msg for the full range of information available
}
  </code>
</pre>

<hr>
<h2>Uploading Proofs</h2>

<p>
To receive points for completing a task, a scavenger robot must upload proof
that they have done so. The format of the proof (e.g. image, video) is specified
by the task.
</p>

<p>
Proofs are wrapped by <code>scavenger_hunt_msgs::Proof</code>. Uploading an
image proof is as simple as creating one and sticking a <code>sensor_msgs::Image</code>
inside.
</p>

<pre>
  <code class="language-cpp">
#include &lt;scavenger_hunt_msgs/Proof.h&gt;

...

sensor_msgs::Image camera_image; // Image to upload
scavenger_hunt_msgs::Proof proof;
proof.image = camera_image;
proof.task_duration = ros::Time::now().toSec() - time_task_start; // Time to complete task
  </code>
</pre>

<p>
To upload video, provide a filepath instead. For generating video, we recommend
recording a rosbag and using one of several Python scripts available online to
extract an MP4 from it.
</p>

<pre>
  <code class="language-cpp">
proof.type = scavenger_hunt_msgs::Proof::TYPE_VIDEO;
proof.file_path = "/path/to/video";
  </code>
</pre>

<p>
Once the proof message is filled out, the service <code>/scavenger_hunt/send_proof</code>
will accept it along with the task the proof is for.
</p>

<pre>
  <code class="language-cpp">
#include &lt;scavenger_hunt_msgs/SendProof.h&gt;

...

ros::NodeHandle nh;
ros::ServiceClient client_send_proof = nh.serviceClient&lt;scavenger_hunt_msgs::SendProof&gt;(
  "/scavenger_hunt/send_proof"
);

scavenger_hunt_msgs::SendProof send_proof;
send_proof.request.proof = proof;
send_proof.request.task = task; // scavenger_hunt_msgs::Task

client_send_proof.call(send_proof);
unsigned long proof_id = send_proof.response.id;
  </code>
</pre>

<p>
Errors in the upload process are sent to stdout. If the upload succeeded,
the response returns a unique ID for the proof that can be used to retrieve
feedback on it.
</p>

<hr>
<h2>Querying Proof Feedback</h2>

<p>
The UID generated for a proof by the upload process can be used to retrieve
feedback on it.
</p>

<pre>
  <code class="language-cpp">
#include &lt;scavenger_hunt_msgs/GetProofStatus.h&gt;

...

ros::NodeHandle nh;
ros::ServiceClient client_get_status = nh.serviceClient&lt;scavenger_hunt_msgs::GetProofStatus&gt;(
  "/scavenger_hunt/get_proof_status"
);

scavenger_hunt_msgs::GetProofStatus get_status;
get_status.request.id = proof_id;

client_get_status.call(get_status);
// 0 -> Proof is not yet validated
// 1 -> Proof was marked correct
// 2 -> Proof was marked incorrect
unsigned char proof_status = send_proof.response.status;
  </code>
</pre>

            </section>
        </section>
      </div>

      <!-- Footer -->
      <?php include 'components/footer.html';?>

        <!-- Populate nav bar -->
        <script>
            var htmlComponentsPath = 'components/';
        </script>
        <script src="css/index.js"></script>

        <script src="../script/prism.js"></script>
    </body>

    <html>
